import { NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import { prisma } from "@/lib/prisma";
import OpenAI from "openai";

// Check if we're in demo mode (no OpenAI key or demo mode enabled)
const DEMO_MODE =
  !process.env.OPENAI_API_KEY || process.env.DEMO_MODE === "true";

// Initialize OpenAI only if not in demo mode
const openai = DEMO_MODE
  ? null
  : new OpenAI({
      apiKey: process.env.OPENAI_API_KEY,
    });

// Credit costs for different content types
const CREDIT_COSTS = {
  blog: 5,
  social: 1,
  email: 2,
  image: 10,
};

// Mock responses for demo mode
const MOCK_RESPONSES = {
  blog: (prompt) => `# ${prompt.slice(0, 50)}...

## Introduction
This is a demo blog post generated in mock mode. In production, this would be generated by OpenAI's GPT-4.

${prompt}

## Main Content
Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris.

### Key Points
- First important point about the topic
- Second key insight
- Third valuable takeaway

## Conclusion
This demonstrates how the content generation would work. Add your OpenAI API key to see real AI-generated content!

---
*Generated in Demo Mode*`,

  social: (prompt) => `ðŸš€ ${prompt.slice(0, 100)}

âœ¨ This is a demo social media post! 

ðŸ’¡ In production mode with OpenAI API, you'll get amazing AI-generated content.

#Demo #ContentCraft #AI

---
*Demo Mode - Add OpenAI API key for real content*`,

  email: (prompt) => `Subject: ${prompt.slice(0, 60)}

Dear [Recipient],

This is a demo email generated in mock mode. 

${prompt}

In production, this would be a professionally crafted email generated by AI based on your prompt.

Best regards,
[Your Name]

---
*Generated in Demo Mode*`,
};

// Simulate delay for realistic feel
const delay = (ms) => new Promise((resolve) => setTimeout(resolve, ms));

export async function POST(request) {
  try {
    const session = await getServerSession(authOptions);

    if (!session) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const { type, prompt } = await request.json();

    if (!type || !prompt) {
      return NextResponse.json(
        { error: "Missing required fields" },
        { status: 400 }
      );
    }

    // Get user from database
    const user = await prisma.user.findUnique({
      where: { email: session.user.email },
    });

    if (!user) {
      return NextResponse.json({ error: "User not found" }, { status: 404 });
    }

    // Check if user has enough credits
    const creditsNeeded = CREDIT_COSTS[type] || 1;
    if (user.creditsRemaining < creditsNeeded) {
      return NextResponse.json(
        { error: "Insufficient credits" },
        { status: 403 }
      );
    }

    let result = "";

    // DEMO MODE - Generate mock content
    if (DEMO_MODE) {
      // Simulate API delay
      await delay(2000);

      if (type === "image") {
        // Return a better placeholder image from Unsplash
        const imageTopics = {
          landscape: "nature/landscape",
          portrait: "people/portrait",
          abstract: "abstract",
          city: "architecture/city",
          food: "food",
          animal: "animals",
        };

        // Try to detect topic from prompt
        let topic = "nature";
        const promptLower = prompt.toLowerCase();
        if (promptLower.includes("city") || promptLower.includes("building"))
          topic = "architecture";
        else if (promptLower.includes("food") || promptLower.includes("coffee"))
          topic = "food";
        else if (
          promptLower.includes("person") ||
          promptLower.includes("portrait")
        )
          topic = "people";
        else if (
          promptLower.includes("abstract") ||
          promptLower.includes("art")
        )
          topic = "abstract";
        else if (
          promptLower.includes("animal") ||
          promptLower.includes("cat") ||
          promptLower.includes("dog")
        )
          topic = "animals";

        // Use Unsplash for better quality demo images
        result = `https://source.unsplash.com/1024x1024/?${topic},${encodeURIComponent(
          prompt.slice(0, 20)
        )}`;
      } else {
        result = MOCK_RESPONSES[type](prompt);
      }
    }
    // PRODUCTION MODE - Use real OpenAI API
    else {
      if (type === "image") {
        // Generate image with DALL-E
        const response = await openai.images.generate({
          model: "dall-e-3",
          prompt: prompt,
          n: 1,
          size: "1024x1024",
        });

        result = response.data[0].url;
      } else {
        // Generate text content
        const systemPrompts = {
          blog: "You are a professional blog writer. Create engaging, SEO-optimized blog posts.",
          social:
            "You are a social media expert. Create engaging, concise social media posts.",
          email:
            "You are a professional email writer. Create clear, professional emails.",
        };

        const completion = await openai.chat.completions.create({
          model: "gpt-4o-mini",
          messages: [
            {
              role: "system",
              content: systemPrompts[type] || "You are a helpful assistant.",
            },
            {
              role: "user",
              content: prompt,
            },
          ],
          temperature: 0.7,
          max_tokens: 1000,
        });

        result = completion.choices[0].message.content;
      }
    }

    // Deduct credits and save content
    const updatedUser = await prisma.user.update({
      where: { id: user.id },
      data: {
        creditsRemaining: user.creditsRemaining - creditsNeeded,
      },
    });

    // Save generated content to database
    await prisma.content.create({
      data: {
        userId: user.id,
        type,
        prompt,
        result,
        creditsUsed: creditsNeeded,
      },
    });

    return NextResponse.json({
      result,
      creditsRemaining: updatedUser.creditsRemaining,
      demoMode: DEMO_MODE,
    });
  } catch (error) {
    console.error("Generation error:", error);

    // Handle specific OpenAI errors
    if (error.code === "insufficient_quota") {
      return NextResponse.json(
        {
          error:
            "OpenAI API quota exceeded. Please add credits to your OpenAI account.",
        },
        { status: 500 }
      );
    }

    return NextResponse.json(
      { error: error.message || "Failed to generate content" },
      { status: 500 }
    );
  }
}
